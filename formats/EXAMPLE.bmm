-- 
	***********************************************************************************************
	****                                                                                       ****
	**** EXAMPLE SCHEMA FOR USE IN DEVELOPING & MAINTAINING .bmm SCHEMAS                       ****
	****                                                                                       ****
	**** How to use: when developing a new schema, copy this file, or if you are familiar      ****
	**** with the format, another schema file that seems useful. If you use a copy of this     ****
	**** file, DELETE ALL SECTIONS enclosed in '****', like this one.                          ****
	****                                                                                       ****
	**** This schema contains boilerplate text (keep them) and placeholder text enclosed       ****
	**** within ': :'. Replace the latter with your own text, removing the ': :'.              ****
	****                                                                                       ****
	**** Remember, a .bmm file is in ODIN syntax, so you need to stick to ODIN rules.          ****
	**** See here for syntax:                                                                  ****
	**** https://github.com/openEHR/odin                                                       ****
	****                                                                                       ****
	**** Comment lines begin with '--'; blank lines are allowed (encouraged).                  ****
	****                                                                                       ****
	**** Schemas can be and usually should be nested. See the openEHR Examples, and consider   ****
	**** reusing existing 'primitive' and 'basic' types schemas. You can reuse and override    ****
	**** any class with a new definition of the same name.                                     ****
	****                                                                                       ****
	***********************************************************************************************

	***********************************************************************************************
	****                                                                                       ****
	**** The following is a typical header block for use with openEHR and Subversion & Git.    ****
	**** You are not obliged to use the same format.                                           ****
	****                                                                                       ****
	***********************************************************************************************
--
-- 	component:   :openEHR Archetype Project or other project name:
-- 	description: :Short descrption of the schema file for use in the source control system. Longer
--               description typically in the 'schema_description' attribute below.:
-- 	keywords:    :keywords here, e.g. reference model, archetypes, xxxx:
-- 	author:      :Your Name <your.name@xmail.com>:
-- 	support:     :Support URL or other contact:
-- 	copyright:   :Copyright (c) YEAR ORGANISATION:
-- 	license:     :See end of file:
-- 

	***********************************************************************************************
	****                                                                                       ****
	**** The bmm_version attribute needs to be the value of the BMM software with which this   ****
	**** file works; see the following URL to get it.                                          ****
	****                                                                                       ****
	***********************************************************************************************

------------------------------------------------------
-- BMM version on which these schemas are based.
-- Current BMM version can be found as value of 'Bmm_internal_version' in 
--     https://github.com/wolandscat/EOMF/blob/master/library/bmm/core/bmm_definitions.e
--
------------------------------------------------------
bmm_version = <"2.3">

	***********************************************************************************************
	****                                                                                       ****
	**** The following attributes should be self-explanatory. The 'schema_name' attribute is   ****
	**** normally given the name of a top-level package or 'model' from the publishing org.    ****
	****                                                                                       ****
	***********************************************************************************************

------------------------------------------------------
-- schema identification
-- (schema_id computed as <rm_publisher>_<schema_name>_<rm_release>)
------------------------------------------------------
rm_publisher = <"openehr">
schema_name = <"adltest">
rm_release = <"1.0.2">

	***********************************************************************************************
	****                                                                                       ****
	**** The following attributes should be self-explanatory. The 'schema_name' attribute is   ****
	**** normally given the name of a top-level package or 'model' from the publishing org.    ****
	****                                                                                       ****
	***********************************************************************************************

------------------------------------------------------
-- schema documentation
------------------------------------------------------
schema_revision = <"$LastChangedRevision: 26 $">
schema_lifecycle_state = <"stable">
schema_description = <"openEHR schema to support test archetypes">

	***********************************************************************************************
	****                                                                                       ****
	**** This is where you say what schemas are to be included in this one. Construct the      ****
	**** inclusion hierarchy in the same logical fashion as for XML schema or similar.         ****
	****                                                                                       ****
	****        includes = <                                                                   ****
	****            ["1"] = <                                                                  ****
	****                id = <"some_schema_id">                                                ****
	****            >                                                                          ****
	****            ["2"] = <                                                                  ****
	****                id = <"some_other_schema_id">                                          ****
	****            >                                                                          ****
	****        >                                                                              ****
	****                                                                                       ****
	***********************************************************************************************

------------------------------------------------------
-- inclusions
------------------------------------------------------
includes = <
	["1"] = <
		id = <"openehr_basic_types_1.0.2">
	>
>

	***********************************************************************************************
	****                                                                                       ****
	**** One archetyping related attribute can be set below, but would not usually all         ****
	**** in the same schema.                                                                   ****
	****                                                                                       ****
	***********************************************************************************************

------------------------------------------------------
-- archetyping
------------------------------------------------------
archetype_namespace = <"TEST_PKG">


	***********************************************************************************************
	****                                                                                       ****
	**** The packages definition should be self-explanatory: just name the classes and         ****
	**** packages in a recursive fashion.                                                      ****
	**** IMPORTANT:                                                                            ****
	****   1. only top-level package ids can be paths (i.e. contain the '.' character)         ****
	****   2. only classes defined in the same schema can be referenced in the package section ****
	****      in that schema.                                                                  ****
	****   3. make sure that the ODIN 'keys' are the same as the 'name' attributes in each     ****
	****      block, thus:                                                                     ****
	****        ["org.openehr.test_pkg"] = <                                                   ****
	****             name = <"org.openehr.test_pkg">                                           ****
	****                                                                                       ****
	***********************************************************************************************

------------------------------------------------------
-- packages
------------------------------------------------------
packages = <
	["org.openehr.test_pkg"] = <
		name = <"org.openehr.test_pkg">
		classes = <"WHOLE", "SOME_TYPE", "BOOK", "CHAPTER", "ENTRY", "CAR", "CAR_BODY">
	>
>

	***********************************************************************************************
	****                                                                                       ****
	**** Now come the classes. There are two categories: one called 'prmitive_types', reserved ****
	**** for defining the minimal semantics of built-in classes. This is typically only used   ****
	**** in a low-level schema included by all other scheams. The syntax is the same as for    ****
	**** main class definition section; the 'primitive' distinction is used by tools for       ****
	**** various display and potentially other purposes.                                       ****
	****                                                                                       ****
	***********************************************************************************************

------------------------------------------------------
-- primitive types
------------------------------------------------------

primitive_types = <
	["Any"] = <
		name = <"Any">
		is_abstract = <True>
	>
	["Ordered"] = <
		name = <"Ordered">
		is_abstract = <True>
		ancestors = <"Any", ...>
	>
>

	***********************************************************************************************
	****                                                                                       ****
	**** Now come the main class definitions.                                                  ****
	**** some example classes follow, showing the various specification possibilities.         ****
	**** NOTES:                                                                                ****
	**** If you include a class C in this schema, and there is a class C (i.e. same name) in   ****
	**** an included schema, the one here will override the included defiintion. This is how   ****
	**** to minimally customise an existing schema.                                            ****
	****                                                                                       ****
	***********************************************************************************************

------------------------------------------------------
-- classes
------------------------------------------------------

class_definitions = <

	--
	-- -------------------- classes for validity tests ---------------------
	--

	***********************************************************************************************
	****                                                                                       ****
	**** The ["ITEM"] below is a ODIN key, used to key a Hash of all defined classes. So make  ****
	**** sure to keep it the same as the Name. Note that keys will always be compared in a     ****
	**** case-insensitive fashion, but the class name may be in any case you like, and its     ****
	**** appearance should be preserved by the tools in display & reporting.                   ****
	****                                                                                       ****
	**** Possible class-level properties:                                                      ****
	**** 'ancestors' - defines any classes from which this class inherits.                     ****
	**** 'is_abstract' - indicates that the class cannot be instantiated directly.             ****
	****                                                                                       ****
	***********************************************************************************************

	***********************************************************************************************
	****                                                                                       ****
	**** Optionality                                                                           ****
	**** Below, various types of property definitions are explained. In all property types,    ****
	**** the 'is_mandatory' attribute can be used to indicate optionality or otherwise.        ****
	****                                                                                       ****
	***********************************************************************************************

	["ITEM"] = <
		name = <"ITEM">
		ancestors = <"Any", ...>
		is_abstract = <True>
	>

	["ELEMENT"] = <
		name = <"ELEMENT">
		ancestors = <"ITEM", ...>
		properties = <

	***********************************************************************************************
	****                                                                                       ****
	**** The following is a SINGLE PROPERTY DEFINITION, i.e. corresponding to a single-valued  ****
	**** attribute from a typical UML or other data model.                                     ****
	****                                                                                       ****
	***********************************************************************************************

			["null_flavour"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"null_flavour">
				type = <"DV_CODED_TEXT">
				is_mandatory = <True>
			>
			["value"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"value">
				type = <"DATA_VALUE">
			>
		>
	>

	["CLUSTER"] = <
		name = <"CLUSTER">
		ancestors = <"ITEM", ...>
		properties = <

	***********************************************************************************************
	****                                                                                       ****
	**** The following is a CONTAINER PROPERTY DEFINITION, whose type_def part indicates the   ****
	**** type of the container (must be known elsewhere in the schema, typically in the primi- ****
	**** tive types schema.                                                                    ****
	**** The optional 'cardinality' property indicates cardinality of the container, and is    ****
	**** expressed as a ODIN range. The default is |0..*|                                      ****
	****                                                                                       ****
	***********************************************************************************************

			["items"] = (P_BMM_CONTAINER_PROPERTY) <
				name = <"items">
				type_def = <
					container_type = <"List">
					type = <"ITEM">
				>
				cardinality = <|>=1|>
				is_mandatory = <True>
			>
		>
	>

	***********************************************************************************************
	****                                                                                       ****
	**** The following is a GENERIC CLASS DEFINITION with OPEN GENERIC PROPERTIES. Each such   ****
	**** property indicates which generic parameter type it is i.e. 'T', 'U' etc.              ****
	**** Each such parameter has its own part in the 'generic_parameter_defs' section, with an ****
	**** optional 'conforms_to_type' setting indicating that the type is constrained.          ****
	****                                                                                       ****
	***********************************************************************************************

	["Interval"] = <
		name = <"Interval">
		ancestors = <"Any", ...>
		generic_parameter_defs = <
			["T"] = <
				name = <"T">
				conforms_to_type = <"Ordered">
			>
		>
		properties = <
			["lower"] = (P_BMM_SINGLE_PROPERTY_OPEN) <
				name = <"lower">
				type = <"T">
			>
			["upper"] = (P_BMM_SINGLE_PROPERTY_OPEN) <
				name = <"upper">
				type = <"T">
			>
		>
	>

	***********************************************************************************************
	****                                                                                       ****
	**** Another GENERIC CLASS DEFINITION, this time inheriting its main definition from a     ****
	**** parent class, here Interval.                                                          ****
	****                                                                                       ****
	***********************************************************************************************

	["DV_INTERVAL"] = <
		name = <"DV_INTERVAL">
		ancestors = <"Interval", "DATA_VALUE">
		generic_parameter_defs = <
			["T"] = <
				name = <"T">
				conforms_to_type = <"DV_ORDERED">
			>
		>
	>

	["SOME_TYPE"] = <
		name = <"SOME_TYPE">
		ancestors = <"Any", ...>
		properties = <

	***********************************************************************************************
	****                                                                                       ****
	**** The following is a GENERIC PROPERTY DEFINITION, i.e. corresponding to a property      ****
	**** whose type is a generic class from the reference model. Container classes are the     ****
	**** most common form of gneeric class by far, and so have their own dedicated definition  ****
	**** format (above). Non-container generic classes are defined with a 'root_class' and one ****
	**** or more 'generic_parameters'.                                                         ****
	****                                                                                       ****
	***********************************************************************************************

			["qty_interval_attr_1"] = (P_BMM_GENERIC_PROPERTY) <
				name = <"qty_interval_attr_1">
				type_def = <
					root_type = <"DV_INTERVAL">
					generic_parameters = <"DV_QUANTITY">
				>
			>
	***********************************************************************************************
	****                                                                                       ****
	**** The following is a nested CONTAINER PROPERTY DEFINITION, i.e. corresponding to a      ****
	**** whose type is a container class (here, List) where the contained type paremeter is    ****
	**** itself generic, and conforms to some other generic class defined in the same model.   ****
	****                                                                                       ****
	**** Since the contained type is generic, it is expressed as a structure, and introduced   ****
	**** with 'type_def' instead of just 'type'. The general rule is 'type' is used for a      ****
	**** simeple string type name, and 'type_def' for a structured type reference.             ****
	****                                                                                       ****
	***********************************************************************************************
			["careProvider"] = (P_BMM_CONTAINER_PROPERTY) <
				name = <"careProvider">
				type_def = <
					container_type = <"List">
					type_def = (P_BMM_GENERIC_TYPE) <
						root_type = <"ResourceReference">
						generic_parameters = <"Party">
					>
				>
				cardinality = <|>=0|>
			>
		>
	>

	***********************************************************************************************
	****                                                                                       ****
	**** The following is a GENERIC CLASS DEFINITION, where a property type is of another      ****
	**** generic type, here DV_INTERVAL. In the following type, there is a property whose type ****
	**** is a nested generic types based on the type REFERENCE_RANGE.                          ****
	****                                                                                       ****
	***********************************************************************************************

	["REFERENCE_RANGE"] = <
		name = <"REFERENCE_RANGE">
		ancestors = <"Any", ...>
		generic_parameter_defs = <
			["T"] = <
				name = <"T">
				conforms_to_type = <"DV_ORDERED">
			>
		>
		properties = <
			["range"] = (P_BMM_SINGLE_PROPERTY) <
				name = <"range">
				type = <"DV_INTERVAL">
				is_mandatory = <True>
			>
		>
	>

	["RANGE_OF_INTERVAL_OF_QUANTITY"] = <
		name = <"RANGE_OF_INTERVAL_OF_QUANTITY">
		ancestors = <"Any", ...>
		properties = <

	***********************************************************************************************
	****                                                                                       ****
	**** The following property definition is based on the above class REFERENCE_RANGE, and in ****
	**** this case, has a generic parameter type that is another generic type: DV_INTERVAL<    ****
	**** DV_QUANTITY>. To express this, we use 'generic_parameter_defs' instead of             ****
	**** just 'generic_parameters' to specify a type structure, rather than just a string type ****
	**** name. Note that 'generic_parameter_defs' is a logical list in general, since there    ****
	**** can always be more than one generic parameter, i.e. 'T', 'U' etc, even though it is   ****
	**** most commonly just one. Accordingly, the usual ODIN hash/list structure is used       ****
	**** with each member being keyed by a generic parameter name, below ["T"]. Additionally,  ****
	**** Since each member of the list could be any descendant of the type 'P_BMM_TYPE',       ****
	**** the usual type marker needs to be included.                                           ****
	****                                                                                       ****
	***********************************************************************************************

			["range"] = (P_BMM_GENERIC_PROPERTY) <
				name = <"range">
				type_def = <
					root_type = <"REFERENCE_RANGE">
					generic_parameter_defs = <
						["T"] = (P_BMM_GENERIC_TYPE) <
							root_type = <"DV_INTERVAL">
							generic_parameters = <"DV_QUANTITY">
						>
					>
				>
			>
		>
	>

	***********************************************************************************************
	****                                                                                       ****
	**** The following example just does the same as the one above, but shows an (unrealistic) ****
	**** but legal extreme case of multiple, mixed, nested generic parameters.                 ****
	****                                                                                       ****
	**** The general rule for expressing types is clearly illustrated:                         ****
	****    - use 'type' for simple string type refs; use 'type_def' for structure types       ****
	****    - within P_BMM_GENERIC_TYPE, use 'generic_parameters' for a list of string types   ****
	****      and 'generic_parameter_defs' for a list of complex type references.              ****
	****                                                                                       ****
	***********************************************************************************************

	["MIXED_GENERIC_PARAM_TYPE"] = <
		name = <"MIXED_GENERIC_PARAM_TYPE">
		ancestors = <"Any", ...>
		properties = <
			["range"] = (P_BMM_GENERIC_PROPERTY) <
				name = <"range">
				type_def = <
					root_type = <"REFERENCE_RANGE">
					generic_parameter_defs = <
						["T"] = (P_BMM_GENERIC_TYPE) <
							root_type = <"DV_INTERVAL">
							generic_parameters = <"DV_QUANTITY">
						>
						["U"] = (P_BMM_SIMPLE_TYPE) <
							type = <"Integer">
						>
						["V"] = (P_BMM_CONTAINER_TYPE) <
							type = <"DV_QUANTITY">
							container_type = <"List">
						>
						["W"] = (P_BMM_CONTAINER_TYPE) <
							type_def = (P_BMM_GENERIC_TYPE) <
								root_type = <"DV_INTERVAL">
								generic_parameters = <"DV_QUANTITY">
							>
							container_type = <"List">
						>
					>
				>
			>
		>
	>

	***********************************************************************************************
	****                                                                                       ****
	**** The following is an enumerated class based on the underlying String type. The names   ****
	**** and values are defined in separate lists whose lengths must match.                    ****
	****                                                                                       ****
	***********************************************************************************************

	["MAGNITUDE_STATUS"] = (P_BMM_ENUMERATION_STRING) <
		name = <"MAGNITUDE_STATUS">
		ancestors = <"String", ...>
		item_names = <"le", "ge", "eq", "approx_eq">
		item_values = <"<=", ">=", "=", "~">
	>

	***********************************************************************************************
	****                                                                                       ****
	**** The following is an enumerated class based on the underlying String type. The names   ****
	**** are defined, but not values - the values default to the name strings.                 ****
	****                                                                                       ****
	***********************************************************************************************

	["NAME_PART"] = (P_BMM_ENUMERATION_STRING) <
		name = <"NAME_PART">
		ancestors = <"String", ...>
		item_names = <"FIRST", "MIDDLE", "LAST">
	>

	***********************************************************************************************
	****                                                                                       ****
	**** The following is an enumerated class based on the underlying Integer type. The names  ****
	**** are defined, but no values, because for the Integer based enumeration type, numbers   ****
	**** from 0, 1, 2, etc are assigned if no integer values are given.                        ****
	****                                                                                       ****
	***********************************************************************************************

	["PROPORTION_KIND"] = (P_BMM_ENUMERATION_INTEGER) <
		name = <"PROPORTION_KIND">
		ancestors = <"Integer", ...>
		item_names = <"pk_ratio", "pk_unitary", "pk_percent", "pk_fraction", "pk_integer_fraction">
	>

	***********************************************************************************************
	****                                                                                       ****
	**** The following is an enumerated class based on the underlying Integer type. The names  ****
	**** and values are fully defined in this case.                                            ****
	****                                                                                       ****
	***********************************************************************************************

	["PROPORTION_KIND_2"] = (P_BMM_ENUMERATION_INTEGER) <
		name = <"PROPORTION_KIND_2">
		ancestors = <"Integer", ...>
		item_names = <"pk_ratio", "pk_unitary", "pk_percent", "pk_fraction", "pk_integer_fraction">
		item_values = <0, 1001, 1002, 1003>
	>

>

--|
--| ***** BEGIN LICENSE BLOCK *****
--| Version: MPL 1.1/GPL 2.0/LGPL 2.1
--|
--| The contents of this file are subject to the Mozilla Public License Version
--| 1.1 (the 'License'); you may not use this file except in compliance with
--| the License. You may obtain a copy of the License at
--| http://www.mozilla.org/MPL/
--|
--| Software distributed under the License is distributed on an 'AS IS' basis,
--| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
--| for the specific language governing rights and limitations under the
--| License.
--|
--| The Original Code is EXAMPLE.bmm.ex
--|
--| The Initial Developer of the Original Code is Thomas Beale.
--| Portions created by the Initial Developer are Copyright (C) 2009
--| the Initial Developer. All Rights Reserved.
--|
--| Contributor(s):
--|
--| Alternatively, the contents of this file may be used under the terms of
--| either the GNU General Public License Version 2 or later (the 'GPL'), or
--| the GNU Lesser General Public License Version 2.1 or later (the 'LGPL'),
--| in which case the provisions of the GPL or the LGPL are applicable instead
--| of those above. If you wish to allow use of your version of this file only
--| under the terms of either the GPL or the LGPL, and not to allow others to
--| use your version of this file under the terms of the MPL, indicate your
--| decision by deleting the provisions above and replace them with the notice
--| and other provisions required by the GPL or the LGPL. If you do not delete
--| the provisions above, a recipient may use your version of this file under
--| the terms of any one of the MPL, the GPL or the LGPL.
--|
--| ***** END LICENSE BLOCK *****
--|

